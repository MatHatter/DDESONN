# 1) Set traps
trace(base::print,
      tracer = quote({
        if (is.null(x)) { cat("\n<base::print got NULL>\n"); utils::str(sys.calls()) }
      }),
      print = FALSE)

if ("print.default" %in% methods("print")) {
  trace("print.default",
        tracer = quote({
          if (is.null(x)) { cat("\n<print.default got NULL>\n"); utils::str(sys.calls()) }
        }),
        print = FALSE)
}

if (requireNamespace("ggplot2", quietly = TRUE)) {
  pg <- getS3method("print", "ggplot", optional = TRUE)
  if (!is.null(pg)) {
    trace(pg,
          tracer = quote({ cat("\n<print.ggplot called>\n"); utils::str(sys.calls()) }),
          print = FALSE)
  }
}

# 2) Run with echo so you see the line before the NULL shows
source("TestDESONN.R", echo = TRUE, max.deparse.length = Inf)

# 3) Clean up
untrace(base::print)
if ("print.default" %in% methods("print")) untrace("print.default")
if (exists("pg") && !is.null(pg)) suppressWarnings(untrace(getS3method("print","ggplot", optional = TRUE)))


#########################

trace(base::print, tracer = quote({
  if (is.logical(x) && length(x)==1L && isTRUE(x)) {
    cat("\n<printed TRUE>\n"); utils::str(sys.calls())
  }
}), print = FALSE)

# ... run your code ...

untrace(base::print)



# ===============================
# R sink() Cheat Sheet (stdout/stderr)
# ===============================

# --- What sink() does ---
# sink() redirects console output.
#   sink()                  -> redirects stdout (cat, print)
#   sink(type="message")    -> redirects stderr (message, warnings)
# If you forget to unsink, output can "disappear".

# --- Check current sinks ---
sink.number()                      # active stdout sinks (0 = none)
sink.number(type = "message")      # active stderr sinks (0 = none)

# --- Clear ALL sinks (safe reset) ---
while (sink.number() > 0) sink()                               # stdout
while (sink.number(type = "message") > 0) sink(type = "message")  # stderr

# --- Quick test after reset ---
cat("CAT to stdout is back.\n"); flush.console()
message("MESSAGE to stderr is back.")

# --- One-liners you can paste any time ---
# Report:
cat(sprintf("stdout sinks: %d | stderr sinks: %d\n",
            sink.number(), sink.number(type="message")))

# Full clear:
while (sink.number() > 0) sink()
while (sink.number(type="message") > 0) sink(type="message")

# --- Helper functions you can keep around ---
checkSinks <- function() {
  list(stdout = sink.number(), stderr = sink.number(type = "message"))
}

resetSinks <- function(verbose = TRUE) {
  n_out <- sink.number()
  n_err <- sink.number(type = "message")
  
  if (n_out > 0) for (i in seq_len(n_out)) sink()
  if (n_err > 0) for (i in seq_len(n_err)) sink(type = "message")
  
  if (verbose) message(
    sprintf("resetSinks(): cleared stdout=%d, stderr=%d", n_out, n_err)
  )
}


# --- Safe sink pattern (won't leak even on error) ---
# Use this to log while still seeing console output (split=TRUE).
safe_with_sink <- function(expr, logfile = "train.log", split_to_console = TRUE) {
  con <- file(logfile, open = "wt")
  sink(con, split = split_to_console)
  sink(con, type = "message", split = split_to_console)
  on.exit({
    # Always restore sinks and close the file
    while (sink.number() > 0) sink()
    while (sink.number(type = "message") > 0) sink(type = "message")
    close(con)
  }, add = TRUE)
  force(expr)
}

# Example:
# safe_with_sink({
#   cat("This goes to console and log.\n")
#   message("So does this.")
#   # ... your training loop ...
# }, logfile = "train.log", split_to_console = TRUE)

